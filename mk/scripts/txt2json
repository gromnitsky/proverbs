#!/usr/bin/env node

'use strict';

let path = require('path')
let fs = require('fs')
let util = require('util')

let lunr = require('lunr')


let usage = function() {
    console.error(`Usage: ${path.basename(process.argv[1])} file1.txt [file2.txt ...]`)
    process.exit(1)
}

let parse_tags = function(line) {
    return line.split(',').map(function(val) { return val.trim() })
}

let tags_union = function(a, b) {
    return a.concat(b.filter(function (item) {
	return a.indexOf(item) < 0
    }))
}

let data_index_of = function(data, id) {
    for (let idx in data) {
	if (data[idx].id === id) return idx
    }
    return -1
}

let tags_stem = function(pair) {
    if (pair[0] && pair[1]) {
	let p1 = lunr.stemmer(pair[0])
	let p2 = lunr.stemmer(pair[1])
	if (p1 === p2) {
	    // return the shortest word
	    return [pair[0].length < pair[1].length ? pair[0] : pair[1]]
	}
    }
    return pair
}

let origin = {
    'Europe': ['Spanish', 'Slavic', 'Italian', 'French', 'English', 'Ukrainian', 'German', 'Danish', 'St Augustine', 'Rumanian', 'Roman', 'Portuguese', 'Albanian', 'Greek', 'Irish', 'Welsh', 'Swedish', 'Norwegian', 'Dutch', 'Scottish', 'Polish', 'the Bible', 'Serbian', 'Catalan', 'Sicilian', 'Georgian', 'Estonian', 'Belgian', 'Icelandic', 'Swiss', 'Finnish', 'Croatian', 'Hungarian', 'Jesus', 'Czech', 'Maltese', 'St Paul', 'Bulgarian', 'Flemish', 'Christian', 'Lithuanian', 'Basque', 'Latvian', 'Bosnian', 'British'],
    'Middle East': ['Yiddish', 'Turkish', 'Moroccan', 'Lebanese', 'Egyptian', 'Ethiopian', 'Arabian', 'Kashmiri', 'Persian', 'Kurdish', 'Afghani', 'Urdu', 'Syrian', 'Ancient Sumerian', 'Yemeni', 'Libyan'],
    // TODO: split Asia
    'Asia': ['Chinese', 'Russian', 'Korean', 'Japanese', 'Tamil', 'Burmese', 'Filipino', 'Indian', 'Hindi', 'Vietnamese', 'Armenian', 'Malaysian', 'Siamese', 'Malay', 'Indonesian', 'Confucius', 'Malayan', 'Buddhist', 'Mongolian', 'Thai', 'Bengali', 'Tibetan', 'Punjabi', 'Hindu', 'Balinese', 'Laotian', 'Taoist', 'Samurai', 'Nepalese'],
    'Latin America': ['Guatemalan', 'Honduran', 'Mexican', 'Puerto Rican', 'Colombian', 'Brazilian', 'Ecuadorian', 'Argentine'],
    'Caribbean': ['Jamaican', 'Belizean'],
    'America': ['American', 'Poor Richard', 'American Army', 'Native American', 'The Editor'],
    'Africa': ['Zulu', 'Hausan', 'Swahili', 'African', 'Yoruban', 'Madagascan', 'Nigerian', 'West African', 'Tanzanian', 'Cambodian', 'Ugandan', 'Liberian', 'Singhalese', 'Kenyan', 'Rwandan', 'Sierra Leonean', 'Masai', 'Guinean', 'Ashanti', 'Somalian', 'Sudanese'],
    'Polynesia': ['Polynesian', 'Hawaiian', 'Fijian', 'Haitian', 'Maori'],
    'Wordwide': ['Unknown']
}

let origin_cache_make = function(origin) {
    let r = {}
    for (let origin_name in origin) {
	for (let place of origin[origin_name]) {
	    r[place] = origin_name
	}
    }
    return r
}

let origin_cache = origin_cache_make(origin)

let data_origin_get = function(tags) {
    for (let tag of tags) {
	if (tag in origin_cache) {
	    return origin_cache[tag]
	}
    }
    throw new Error(`no origin for ${tags}`)
}

let parse = function(file) {
    let data = []
    let text = fs.readFileSync(file).toString().split("\n")

    let tags = []
    let cache = {}
    let index = 0
    for (let line of text) {
	if (line.match(/^(\s*$|#.*)$/)) continue // comments & empty lines

	if (!line.match(/[.?!]/)) {
	    tags = tags_stem(parse_tags(line))
	    continue
	}

	// 'line' contains a proverb
	let parts = line.trim().match(/^(.+)\s+\((.+?)\)$/)
	let proverb = parts[1]
	let ctags = tags_union(tags, parse_tags(parts[2]))
	if (proverb in cache) {
	    // append new tags to an existing entry
	    let idx = data_index_of(data, cache[proverb])
	    data[idx].t = tags_union(data[idx].t, ctags)
	} else {
	    data.push({
		id: index,
		p: proverb,
		t: ctags,
		o: data_origin_get(ctags)
	    })

	    cache[proverb] = index++
	}
    }

    return data
}

if (process.argv.length < 3) usage()

let arr = process.argv.slice(2).map(parse)
//console.log(util.inspect(arr[0], { depth: null }))
process.stdout.write(JSON.stringify(arr))
